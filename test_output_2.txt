============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-8.4.1, pluggy-1.6.0
rootdir: C:\codex\databarn
plugins: anyio-4.10.0, typeguard-4.4.4
collected 1 item

tests\test_funcs.py F                                                    [100%]

================================== FAILURES ===================================
_________________________ test_dict_to_cob_with_model _________________________

    def test_dict_to_cob_with_model():
        """Test using `model` argument with custom Cob classes."""
        from databarn import Grain, create_child_cob_grain, create_child_barn_grain
    
        class Payload(Cob):
            model: str = Grain(required=True)
            temperature: float = Grain()
            max_tokens: int = Grain()
            reasoning_effort: str = Grain() # Reasoning effort is not supported in deepseek
            stream: bool = Grain(default=False)
    
            @create_child_cob_grain("response_format")
            class ResponseFormat(Cob):
                type: str = Grain("json_object")
    
            @create_child_barn_grain('messages')
            class Message(Cob):
                role: str = Grain(required=True)
                content: str = Grain(required=True)
    
        class Person(Cob):
            address: str = Grain()
    
            @create_child_cob_grain("natural")
            class Natural(Cob):
                first_name: str = Grain(required=True)
                last_name: str = Grain(required=True)
    
            @create_child_cob_grain("legal")
            class Legal(Cob):
                company_name: str = Grain(required=True)
                registration_number: str = Grain(required=True)
    
        # Test Payload
        payload_data = {
            "model": "gpt-4",
            "temperature": 0.7,
            "max_tokens": 100,
            "reasoning_effort": "high",
            # stream uses default
            "response_format": {"type": "text"},
            "messages": [
                {"role": "user", "content": "hello"},
                {"role": "assistant", "content": "hi"}
            ]
        }
    
>       payload = dict_to_cob(payload_data, model=Payload)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_funcs.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dikt = {'max_tokens': 100, 'messages': [{'content': 'hello', 'role': 'user'}, {'content': 'hi', 'role': 'assistant'}], 'model': 'gpt-4', 'reasoning_effort': 'high', ...}
model = <class 'test_funcs.test_dict_to_cob_with_model.<locals>.Payload'>
replace_space_with = '_', replace_dash_with = '__', suffix_keyword_with = '_'
prefix_leading_num_with = 'n_', replace_invalid_char_with = '_'
suffix_existing_attr_with = '_', custom_key_converter = None

    def dict_to_cob(dikt: dict,
                    model: type[Cob] = Cob,
                    replace_space_with: str | None = "_",
                    replace_dash_with: str | None = "__",
                    suffix_keyword_with: str | None = "_",
                    prefix_leading_num_with: str | None = "n_",
                    replace_invalid_char_with: str | None = "_",
                    suffix_existing_attr_with: str | None = "_",
                    custom_key_converter: Callable | None = None) -> Cob:
        """Recursively converts a dictionary to a Cob-like object.
    
        If a value is a list of dictionaries, each dictionary is converted to
        a Cob-like object and the list is converted to a Barn-like object.
        Every converted key is stored in the correspoding cob.__dna__.get_grain(label).key.
        So that when the cob is converted back to a dict, the original keys are preserved.
    
        All keys are converted to string and to a valid Python variable name, following these rules:
        - Spaces can be replaced with a specified string (default is "_").
        - Dashes can be replaced with a specified string (default is "__" (dunder)).
        - If a key is a Python keyword, a specified string can be appended (default is "_").
        - If a key starts with a number, a specified string can be prepended (default is "n_").
        - Non-alphanumeric (and not underscore) chars can be replaced with a specified string
            (default is "_").
        - If a key conflicts with an existing Cob attribute, a specified string can be appended
            (default is "_").
        - A custom key conversion function can be provided to override the above rules.
        - If after all replacements, a key is still not a valid identifier, an InvalidGrainLabelError is raised.
        - If after all replacements, two keys conflict, an InvalidGrainLabelError is raised.
    
        Args:
            dikt (dict): The dictionary to convert.
            model (type[Cob]): The Cob-like class to instantiate. Default is Cob.
            replace_space_with (str | None): The string to replace spaces in keys with.
                If None, spaces are not replaced. Default is "_".
            replace_dash_with (str | None): The string to replace dashes in keys with.
                If None, dashes are not replaced. Default is "__" (dunder).
            suffix_keyword_with (str | None): The string to append to keys that are
                Python keywords. If None, keywords are not modified. Default is "_".
            prefix_leading_num_with (str | None): The string to prepend to keys that
                start with a number. If None, leading numbers are not modified.
                Default is "n_".
            replace_invalid_char_with (str | None): The string to replace invalid
                characters in keys with. If None, invalid characters are not replaced.
                Default is "_".
            suffix_existing_attr_with (str | None): The string to append to keys that
                conflict with existing Cob attributes. If None, existing attributes
                are not modified. Default is "_".
            custom_key_converter (Callable | None): A custom function that takes a key
                and returns a modified string key. If provided, this function is used instead
                of the above replacement rules.
    
        Returns:
            Cob: The converted Cob-like object."""
        if not isinstance(dikt, dict):
            raise TypeError("'dikt' must be a dictionary.")
        label_value_map = {}
        label_child_cobs_map = {}
        label_key_map = {}
        for key, value in dikt.items():
            label: str = _key_to_label(key=key,
                                       replace_space_with=replace_space_with,
                                       replace_dash_with=replace_dash_with,
                                       suffix_keyword_with=suffix_keyword_with,
                                       prefix_leading_num_with=prefix_leading_num_with,
                                       replace_invalid_char_with=replace_invalid_char_with,
                                       suffix_existing_attr_with=suffix_existing_attr_with,
                                       custom_key_converter=custom_key_converter,)
            _verify_label(label, key, label_key_map)
            label_key_map[label] = key
    
            outcome = _process_dict_if(value=value, model=model, label=label,
                                       replace_space_with=replace_space_with,
                                       replace_dash_with=replace_dash_with,
                                       suffix_keyword_with=suffix_keyword_with,
                                       prefix_leading_num_with=prefix_leading_num_with,
                                       replace_invalid_char_with=replace_invalid_char_with,
                                       suffix_existing_attr_with=suffix_existing_attr_with,
                                       custom_key_converter=custom_key_converter)
            target_dict: dict = label_value_map
            if outcome.is_child_barn_ref:
                target_dict = label_child_cobs_map
            target_dict[label] = outcome.new_value
    
        cob = model(**label_value_map)
        for grain in cob.__dna__.grains:
>           key = label_key_map[grain.label]
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'stream'

databarn\funcs.py:227: KeyError
=========================== short test summary info ===========================
FAILED tests/test_funcs.py::test_dict_to_cob_with_model - KeyError: 'stream'
============================== 1 failed in 0.11s ==============================
